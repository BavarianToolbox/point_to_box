# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_utils.ipynb (unless otherwise specified).

__all__ = ['get_norm_stats', 'draw_rect', 'convert_cords']

# Cell
def get_norm_stats(loaders) -> list:
    """Returns normalization stats (mean and std) computed across one or more image dataloaders.

    **Parameters**

    loaders : list of pytorch dataloaders

    **Returns**

    list of stats as pytorch tensors

    """
    mean = 0.
    std = 0.
    nb_samples = 0.
    for loader in loaders:
        for data, _ in loader:
            batch_samples = data.size(0)
            data = data.view(batch_samples, data.size(1), -1)
            mean += data.mean(2).sum(0)
            std += data.std(2).sum(0)
            nb_samples += batch_samples

    mean /= nb_samples
    std /= nb_samples

    return [mean, std]

# Cell
def draw_rect(im, cords, box_format = None, color = None):
    """
    Draw one or more rectangls on an image.

    **Parameters**

    im : numpy image [W, H, C]

    cords : Numpy array containing N bounding boxes [N, 4]

    box_format : String indicating bbox-coordinate format

        - coco     : [xmin, ymin, w, h]
        - cnt_ofst : [xofst, yofst, w, h]
        - *_frac   : as fraction of image width/height
        - None     : [xmin, ymin, xmax, ymax]


    color : List of one or more colors [[R, G, B]]

    **Returns**

    numpy image with bounding boxes drawn on it [W, H, C]

    """
    if color:
        assert len(color) in [1 or len(cords)], 'Improper color specification'
        if len(color) == 1:
            color *= len(cords)
    else:
        color = [[255,0,0]]*len(cords)

    im = im.copy()

    cords = cords[:,:4]
    cords = cords.reshape(-1,4)

    for i, cord in enumerate(cords):
        pt1, pt2 = [],[]
        if box_format == 'coco':
            # cord format: [xmin, ymin, boxw, boxh]
            pt1 = (cord[0], cord[1])
            pt2 = (cord[0] + cord[2], cord[1] + cord[3])

        elif box_format == 'cntr_ofst_frac':
            # cord format: [xofst_frac, yofst_frac, frac_boxw, frac_boxh]
            imgh, imgw = im.shape[:-1]
            img_cntr_x, img_cntr_y = imgw/2, imgh/2
            boxw = cord[2] * imgw
            boxh = cord[3] * imgh
            x_ofst = cord[0]*(imgw/2)
            y_ofst = cord[1]*(imgh/2)
            xmin = img_cntr_x + x_ofst - boxw/2
            ymin = img_cntr_y + y_ofst - boxh/2
            pt1 = (xmin, ymin)
            pt2 = (xmin + boxw, ymin + boxh)

        elif box_format == 'corner_ofst_frac':
            # cord format: [xofst_frac, yofst_frac, boxw_farc, boxh_farc]
            imgh, imgw = im.shape[:-1]
            w, h = cord[2] * imgw, cord[3] * imgh
            xmin, ymin = cord[0]*imgw - w/2, cord[1]*imgh - h/2
            pt1 = (xmin , ymin)
            pt2 = (xmin + w, ymin + h)

        elif box_format == 'cntr_ofst':
            # cord format: [xofst, yofst, boxw, boxh]
            imgh, imgw = im.shape[:-1]
            img_cntr_x, img_cntr_y = imgw/2, imgh/2
            xmin = img_cntr_x + cord[0] - cord[2]/2
            ymin = img_cntr_y + cord[1] - cord[3]/2
            pt1 = (xmin, ymin)
            pt2 = (xmin + cord[2], ymin + cord[3])

        else:
            # cord format: [xmin, ymin, xmax, ymax]
            pt1, pt2 = (cord[0], cord[1]) , (cord[2], cord[3])

        pt1 = int(pt1[0]), int(pt1[1])
        pt2 = int(pt2[0]), int(pt2[1])

        im = rectangle(im.copy(), pt1, pt2, color[i], int(max(im.shape[:2])/200))
    return im

# Cell
def convert_cords(cords, img_dims, cord_format):
    """
    Convert bounding box coordinates

    **Parameters**

    cords : list of bbox coordinates [xmin, ymin, w, h]

    img_dims : Image dimensions as list or tuple

    cord_format : Coordinate conversion format

    - cnt_ofst         : [xofst, yofst, w, h]
    - cntr_ofst_frac   : [xofst, yofst, w, h] as fraction of image width/height
    - corner_ofst_frac : [xmin, min, w, h] as fraction of image width/height

    **Returns**

    List of converted box coordinates

    """
    box_cntr = (xmin + (w/2), ymin + (h/2))
    img_cntr = (imgw/2, imgh/2)
    img_dims = (imgw, imgh)

    ofst = []
    for bx_cord, img_cord, img_dim in zip(box_cntr, img_cntr, img_dims):
        if cord_format == 'cntr_ofst':
            ofst.append(bx_cord - img_cord)
        elif cord_format == 'cntr_ofst_frac':
            ofst.append((bx_cord - img_cord)/(img_dim/2))
        elif cord_format == 'corner_ofst_frac':
            ofst.append(bx_cord/img_dim)

    if cord_format in ['cntr_ofst_frac',
                       'corner_ofst_frac']:
        w, h = w/imgw, h/imgh

    return [ofst[0], ofst[1], w, h]